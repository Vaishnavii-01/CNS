Experiment 1: Breaking the Mono-alphabetic Substitution Cipher
Aim: To write a Java program that decrypts a ciphertext encrypted by a mono-alphabetic substitution cipher without knowing the key, using the technique of letter frequency analysis.
Algorithm/Theory:
Mono-alphabetic Cipher: A substitution cipher where each letter of the alphabet is consistently replaced by another letter. For example, every 'A' becomes 'G', every 'B' becomes 'T', etc.
Weakness: This cipher hides the letters, but it fails to hide the statistical properties of the language.
Frequency Analysis: In English, letters are not used equally. 'E' is the most common (around 12.7%), followed by 'T' (9.1%), 'A' (8.2%), and so on. 'Z', 'Q', and 'J' are very rare.
Algorithm:
Take the provided ciphertext.
Write a program to count the occurrences of each letter (A-Z).
Calculate the percentage frequency of each letter in the ciphertext.
Compare the ciphertext frequencies to the known English frequencies.
The most frequent letter in the ciphertext is probably 'E'. The next most frequent is probably 'T', and so on.
Substitute your best guesses (e.g., replace all 'Z' with 'E') and look for readable words or common patterns (like 'THE', 'AND', 'ING') to confirm or deny your guesses.
Solving (The Method): For the given ciphertext: Zio ltkxozol gjqz zlqz tkfqztklz zio ktkxzkotfzkj ykg tqozgfl lt qf oxfzoz zq ftk kqtlzo...
Our Java program would iterate through this entire text.
It would maintain an array of 26 integers, one for each letter.
It would ignore spaces and punctuation, and treat uppercase/lowercase as the same.
It would produce a frequency count. For example (this is just a guess):
Z: 15.2%
Q: 10.1%
T: 8.5%
...etc.
Output Observed: The program's output would be a list of letters and their frequencies. Based on this, we would make our first hypothesis:
The most common English letter is 'E'.
The most common ciphertext letter is 'Z'.
Hypothesis: Z = e
We would then substitute 'e' for 'Z' in the text: eio ltkxoeol gjqe elqe tkfqetkle eio ktkxekotfkj ykg tqoegfl lt qf oxfoe eq ftk kqtleo...
Seeing eio and eio repeated, we can guess this is the. This gives us:
Z = e
I = h
O = t
We would continue this process of guessing, substituting, and refining until the full message is decoded.

Possible Viva Questions:
What is a substitution cipher? (A cipher that replaces one unit of plaintext, like a letter, with one unit of ciphertext).
Why does frequency analysis work? (Because the underlying language's letter frequencies are not hidden, only the letters themselves are).
How would you make this cipher stronger? (By using a polyalphabetic cipher, like Vigenère, which uses multiple substitution alphabets and flattens the frequency distribution).
What is the "CIA Triad"? (Confidentiality, Integrity, Availability. This cipher breaks Confidentiality).
What is a passive attack? (An attack where the intruder only listens to or monitors traffic, like sniffing. Frequency analysis is a form of passive attack on a stored message).

Experiment 2: Cryptanalysis or Decoding of Playfair Cipher
Aim: To implement the Playfair cipher in Java to encrypt and decrypt a message ("Vaishnavi") using a specific key ("October").
Algorithm/Theory: The Playfair cipher is a polygraphic substitution cipher that encrypts pairs of letters (digraphs). Our Java code implements this through several functions:
Pre-processing (toLowerCase, removeSpaces, replaceJ): The code first converts both the key and plaintext to lowercase, removes all spaces, and replaces any 'j' with an 'i'.
Key Grid (generateKeyMatrix): A 5x5 grid is created. It's filled first with the unique letters of the key (e.g., "october" -> o, c, t, b, e, r), and then with the remaining letters of the alphabet. 'i' and 'j' are treated as the same cell.
Plaintext Prep (processInput): The code processes the plaintext to:
Insert an 'x' between any two identical letters in a pair (e.g., "hello" -> "he" "lx" "lo").
Append an 'x' at the end if the total number of letters is odd.
Encryption Rules (encrypt): For each pair, the code finds their positions (findPosition) and applies one of three rules:
Same Row: Replace each letter with the letter to its right. The code implements this as (column + 1) % 5.
Same Column: Replace each letter with the letter below it. The code implements this as (row + 1) % 5.
Rectangle: Replace each letter with the letter in the same row but at the other corner of the rectangle. The code implements this by swapping the column indices: matrix[row1][col2] and matrix[row2][col1].
Decryption Rules (decrypt): This function implements the exact inverse:
Same Row: (column + 4) % 5 (which is column - 1).
Same Column: (row + 4) % 5 (which is row - 1).
Rectangle: The rule is the same as encryption (swapping columns).
Solving (Key = "October", Name = "Vaishnavi"):
Key: october
Plaintext: vaishnavi
Pre-processed Key: octber
Pre-processed Plaintext: vaishnavi -> va is hn av ix (pad with 'x' for odd length)
Key Grid (generateKeyMatrix):
o c t b e
r a d f g
h i k l m
n p q s u
v w x y z
Encrypt Pairs:
va: Rectangle (v=4,0; a=1,1). Rule: matrix[4][1] and matrix[1][0]. Result: wr
is: Rectangle (i=2,1; s=3,3). Rule: matrix[2][3] and matrix[3][1]. Result: lp
hn: Same Column (h=2,0; n=3,0). Rule: (row+1)%5. Result: nv
av: Rectangle (a=1,1; v=4,0). Rule: matrix[1][0] and matrix[4][1]. Result: rw
ix: Rectangle (i=2,1; x=4,2). Rule: matrix[2][2] and matrix[4][1]. Result: kw
Output Observed: The program first prints the 5x5 Key Matrix.
Encrypted Text : wrlpnvrwkw
Decrypted Text : vaishnavix (The decrypted text matches the pre-processed plaintext, including the padding 'x').

Possible Viva Questions:
What is a polygraphic cipher? (A cipher that encrypts blocks of letters, like 2 in Playfair, instead of one at a time).
Why is Playfair stronger than a simple substitution? (It encrypts 676 possible digraphs, which hides single-letter frequencies).
How do you handle the letter 'j' in your code? (The replaceJ function converts all 'j's to 'i's in both the key and plaintext before processing).
What does your processInput function do? (It handles two key rules: it inserts an 'x' between duplicate letters in a pair and appends an 'x' if the plaintext has an odd length).
What is steganography? (From syllabus. It's the art of hiding a message, e.g., in an image, so no one knows a message even exists. Cryptography scrambles a message).

Experiment 3: Encrypting Long Messages (AES/DES Modes of Operation)
Aim: To understand why block ciphers like AES and DES need "modes of operation" to securely encrypt messages longer than a single block.
Algorithm/Theory:
Block Cipher: A symmetric cipher that encrypts data in fixed-size blocks (DES = 64 bits, AES = 128 bits).
Problem: How to encrypt a 1MB file with a 128-bit (16-byte) cipher?
Modes of Operation are the answer:
ECB (Electronic Codebook):
How: The simplest mode. Each block is encrypted independently with the same key.
Weakness: This is VERY INSECURE. If you have two identical plaintext blocks (e.g., a block of white space in an image), they will encrypt to the exact same ciphertext block. This leaves a "ghost" of the original data, revealing patterns.
CBC (Cipher Block Chaining):
How: Before being encrypted, each plaintext block is XORed with the previous ciphertext block.
IV: The first block needs something to XOR with, so it uses an Initialization Vector (IV), which is a random, one-time-use block.
Strength: This "chaining" ensures that even two identical plaintext blocks will encrypt to completely different ciphertext blocks. It is secure and widely used.
Solving (The Method): We would write a Java program using the javax.crypto library. We would take a bitmap image (which has large areas of identical color) and encrypt it twice:
Once with the transformation AES/ECB/PKCS5Padding.
Once with the transformation AES/CBC/PKCS5Padding.
Output Observed:
This experiment clearly shows that for the exact same plaintext ("Hello I am from INFT department") and the exact same secret key, the choice of mode drastically changes the output.
Screenshot 1 (CBC Mode):
Mode: CBC
IV: 09876543
Output: D0C0920B...E7DE5
Analysis: The IV is used to "randomize" the first block, and the output of each block is chained to the next. This is secure.
Screenshot 2 (ECB Mode):
Mode: ECB
IV: (None used)
Output: 86C49A...029BEF7
Analysis: The output is different from CBC because no IV is used and no chaining occurs. This is insecure as it would reveal patterns in the data.
ECB Output: The encrypted image would still clearly show the outline or "ghost" of the original image. You could tell what it was.
CBC Output: The encrypted image would look like complete and total random noise (static). This is the desired, secure result.

Possible Viva Questions:
Explain the difference between ECB and CBC. (ECB encrypts blocks independently, which is insecure. CBC chains blocks by XORing with the previous ciphertext, which is secure).
What is an IV, and does it need to be secret? (An Initialization Vector. It's used to start the CBC chain. It does not need to be secret, but it must be unique and random for every message).
What is AES? (Advanced Encryption Standard. A symmetric block cipher, 128-bit block size, key sizes of 128, 192, or 256 bits. It is the modern standard).
What is DES? Why is it insecure? (Data Encryption Standard. A symmetric block cipher, 64-bit block size. Its 56-bit key is now too small and can be broken by brute-force).
What is the difference between a block cipher and a stream cipher? (A block cipher encrypts in fixed chunks. A stream cipher encrypts one bit or byte at a time, like RC4).

Experiment 4: Implementation and Analysis of RSA Cryptosystem
Aim:
To implement the RSA asymmetric algorithm in Java using the BigInteger class to perform key generation, encryption, and decryption.
Algorithm/Theory:
RSA is an asymmetric algorithm using a Public Key and a Private Key. Our Java code implements this using BigInteger because the numbers involved are too large for standard int or long.
Key Generation (generateKeys):
The user provides two large primes, p and q.
n = p.multiply(q)
phi = (p-1).multiply(q-1)
The code finds the public exponent e by iterating from 2 upwards until it finds a number e where e.gcd(phi) is 1.
The private exponent d is calculated using d = e.modInverse(phi).
Keys:
Public Key: (e, n) - Shared with everyone.
Private Key: (d, n) - Kept secret.
Encryption (encrypt):
The code uses the modPow function: C = M^e (mod{n}), which is M.modPow(e, n).
Decryption (decrypt):
The code uses the modPow function: M = C^d (mod{n}), which is C.modPow(d, n).
Solving (A Simple Example):
Let's trace the program with user inputs:
Input: p = 7, q = 11.
Key Generation:
n = 7 \times 11 = 77.
phi = (7-1) \times (11-1) = 6 \times 10 = 60.
generateKeys loops to find e: it checks e=2...e=6 (all share factors with 60). It stops at e = 7, because gcd(7, 60) = 1.
d = 7.modInverse(60). The code calculates d such that 7d \equiv 1 (mod{60}). This gives d = 43 (since 7 \times 43 = 301 = 5 \times 60 + 1).
Keys Printed:
Public Key: (7, 77)
Private Key: (43, 77)
Input: Message M = 5.
Encryption:
C = encrypt(5, 7, 77)
C = 5^7 (mod{77}) = 47
Decryption:
M = decrypt(47, 43, 77)
M = 47^{43} \pmod{77} = 5
Output Observed:
The program first prints all the calculated key components:
n : 77
phi (Euler's Quotient): 60
e (Public Exponent): 7
d (Private Exponent): 43
Public Key (e, n): (7, 77)
Private Key (d, n): (43, 77)
Then, it prints the encryption/decryption:
Encrypted Message: 47
Decrypted Message: 5

Possible Viva Questions:
What's the difference between symmetric and asymmetric cryptography? (Symmetric = one shared secret key (e.g., AES). Asymmetric = one public key, one private key (e.g., RSA)).
Why do we use BigInteger in the code? (Because RSA requires numbers that are far too large for standard int or long. BigInteger can handle numbers of virtually unlimited size).
What is the "trapdoor" in RSA? (The security is based on the fact that multiplying p and q to get n is easy, but factoring n back into p and q is extremely hard if the numbers are large).
If RSA is so good, why don't we use it for everything? (It is very, very slow. In practice, we use RSA to encrypt and exchange a symmetric key (like an AES key), and then use the fast AES key to encrypt the actual data. This is called a hybrid cryptosystem).
What else can you do with the private key? (You can "encrypt" with the private key to create a Digital Signature, which proves you are the sender and the message hasn't been tampered with).

Experiment 5: Design and Implement a Product Cipher
Aim:
To design and implement a custom "product cipher" in Java by combining a simple substitution cipher and a simple transposition cipher.
Algorithm/Theory:
A product cipher creates strength by using multiple, different types of ciphers in "rounds." This follows Shannon's principles of Confusion (obscuring the key-ciphertext relationship) and Diffusion (spreading plaintext influence).
Our Java code implements a fixed 2-step product cipher:
Step 1: Substitution (substitute)
The code applies a simple Caesar Cipher with a fixed shift of +3.
c = (char) ((c - base + 3) % 26 + base);
This step provides Confusion.
Step 2: Transposition (fillMatrixRowWise, readMatrixColumnWise)
The code applies a Columnar Transposition using a fixed 4x4 grid.
The substituted text is written into the 4x4 grid row by row (fillMatrixRowWise).
The final ciphertext is read out column by column (readMatrixColumnWise).
This step provides Diffusion.
Decryption: The decryption process must be the exact reverse in the reverse order.
Inverse Transposition: fillMatrixColumnWise, readMatrixRowWise.
Inverse Substitution: reverseSubstitute (which applies a -3 shift).
Solving (Example: Plaintext "SECURITY"):
Input: SECURITY
Step 1 (Substitution +3):
substitute("SECURITY") returns VHFXULWB.
Step 2 (Transposition):
fillMatrixRowWise writes this into a 4x4 grid, padding with 'X':
V H F X
U L W B
X X X X
X X X X


readMatrixColumnWise reads down the columns:
Column 1: VUX X
Column 2: HLX X
Column 3: FWX X
Column 4: XBX X
Final Ciphertext: VUX X HLX X FWX X XBX X
Output Observed:
The program first asks for plaintext and truncates it to 16 letters.
After Substitution (+3) : VHFXULWB
Matrix :
V H F X 
U L W B 
X X X X 
X X X X 


Encrypted text (column-wise) : VUX X HLX X FWX X XBX X
Decrypted text : SECURITYXXXXXXXX
(The decrypted text matches the original, plus the 'X' padding).

Possible Viva Questions:
What is confusion and diffusion? (Confusion hides the key's relationship. Diffusion spreads the plaintext's influence. Substitution = Confusion. Transposition = Diffusion).
Which part of your code provides confusion? (The substitute function, which is a Caesar cipher).
Which part provides diffusion? (The matrix functions (fill.../read...) that perform a columnar transposition).
Why is decryption the "reverse steps in reverse order"? (Because the ciphers are layered. To undo it, you must "unpeel" the last layer (transposition) first, then unpeel the first layer (substitution) second).
Is this cipher secure? (No. Both the substitution shift (+3) and the transposition grid (4x4) are fixed and small, making it very easy to break).

Experiment 6: Study of Packet Sniffer Tool (Wireshark)
Aim: To use the Wireshark tool to capture, view, and filter live network traffic using various display filters to understand network protocols and security vulnerabilities.
Theory:
Wireshark: A passive network analysis tool (a "packet sniffer") that intercepts and logs all network packets.
Promiscuous Mode: The default mode ("non-promiscuous") only captures packets for your computer. Promiscuous mode captures all packets on the local network segment (e.g., all Wi-Fi traffic around you), even if it's for other devices.
Vulnerability: Wireshark reveals any data sent in plain text. This includes unencrypted (HTTP) websites, FTP, Telnet, and some email protocols.
Explanation of Commands (Display Filters): Display filters let you find specific packets in a large capture after you have stopped capturing.
Protocol Filters:
http: Shows only Hypertext Transfer Protocol packets. This is how you see unencrypted web browsing.
dns: Shows only Domain Name System packets. This lets you see all the website lookups (e.g., "https://www.google.com/search?q=google.com" -> 142.250.196.78) your computer is making.
Port Filters:
tcp.port == 80: Shows all traffic using TCP port 80. This is effectively the same as the http filter, as 80 is the standard port for HTTP.
udp.port == 53: Shows all traffic using UDP port 53. This is effectively the same as the dns filter, as 53 is the standard port for DNS.
String Filters:
frame contains "Google": Searches the raw data (the entire frame) of every packet for the literal string "Google". This is a broad search.
frame contains "edge": Similar to above, searches every packet for the string "edge".
http contains "GET": A more specific search. It only looks inside HTTP packets for the string "GET", which is the command your browser uses to request a webpage from a server.
Output Observed:
We started Wireshark capture on our Wi-Fi interface.
We opened a browser and went to http://www.google.com (note: Google often forces HTTPS, but the initial request might be HTTP or DNS).
We stopped the capture.
We applied the filter dns. We observed packets showing our computer (source) asking a DNS server (destination) for the IP address of "www.google.com".
We cleared the filter and applied http. We observed GET / HTTP/1.1 requests from our IP to a Google IP, and the server's response.
We applied the filter frame contains "Google". We saw both the DNS requests (which contained "https://www.google.com/search?q=google.com") and the HTTP packets (which contained "Host: www.google.com"), demonstrating the filter's power.

Possible Viva Questions:
Is Wireshark an active or a passive tool? (It is passive. It just listens, it doesn't send its own packets or modify traffic).
How does Wireshark "detect" an attack? (It doesn't, you do. Wireshark is an analysis tool. An IDS (Intrusion Detection System) is what automatically detects attacks by looking for signatures).
How do you prevent this sniffing attack? (By using encryption. HTTPS (SSL/TLS) encrypts the HTTP traffic, so even if an attacker sniffs the packets, they just see gibberish).
What is an active attack? (An attack that modifies data or the network, e.g., a Man-in-the-Middle (MITM) attack, a DoS attack, or a virus).
What is SSL/TLS? (From syllabus. Secure Sockets Layer / Transport Layer Security. It's the protocol that provides encryption for HTTPS, making web browsing secure).

Experiment 7: Study of nmap Tool
Aim: To use the nmap (Network Mapper) tool with different command-line options to perform network reconnaissance by scanning a target for open ports, running services, and OS version.
Theory:
nmap: An active network scanning tool. It is the first step in an attack: reconnaissance (information gathering).
It works by sending probes to a target's ports to see how they respond.
Port States:
Open: The service is listening (e.g., Port 80 is open for a web server).
Closed: The port is reachable, but no service is listening.
Filtered: nmap can't tell. A firewall is likely blocking the probe.
Explanation of Commands (nmap Options):
nmap -p 1-200 <ip_address>: (Port Range Scan) Scans only the specific TCP ports from 1 through 200.
nmap -F <ip_address>: (Fast Scan) Scans only the 100 most common ports. This is much faster than a full scan.
nmap -p 80 <ip_address>: (Single Port Scan) Scans only TCP port 80. Used to quickly check if a target is running a web server.
nmap -sT <ip_address>: (TCP Connect Scan) This scan completes the full TCP three-way handshake (SYN, SYN/ACK, ACK). It's reliable but very "noisy" and easily logged by firewalls.
nmap -sU <ip_address>: (UDP Scan) Scans for open UDP ports (like DNS/53). This is much slower than TCP scans.
nmap -O <ip_address>: (OS Fingerprinting) Tries to guess the target's operating system (e.g., "Linux 4.x", "Windows 10") by analyzing its network stack.
nmap -A <ip_address>: (Aggressive Scan) A powerful, "noisy" scan that combines several features at once:
OS detection (-O)
Service Version detection (-sV)
Default Script scanning (-sC)
Traceroute
nmap <ip_address>/24: (Subnet Scan) This scans an entire subnet (the /24 means it scans all 256 IPs in that range, e.g., 192.168.1.0 to 192.168.1.255). It's used for host discovery to see which machines are online.
Output Observed: We ran the aggressive scan nmap -A scanme.nmap.org:
Starting Nmap...
Host is up (0.12s latency).
Not shown: 996 filtered ports
PORT     STATE  SERVICE      VERSION
22/tcp   open   ssh          OpenSSH 6.6.1p1 (Protocol 2.0)
80/tcp   open   http         Apache httpd 2.4.7
31337/tcp open  Elite


Device type: general purpose
Running: Linux 3.X
OS details: Linux 3.10 - 3.13
...
Nmap done: 1 IP address (1 host up) scanned in 15.32 seconds
This single -A command told us the host is a Linux server, what ports are open (22, 80), and the exact versions of the services running (OpenSSH 6.6.1, Apache 2.4.7).

Possible Viva Questions:
Is nmap an active or passive tool? (It is active. It actively sends probes to the target).
What's the difference between a SYN scan (-sS) and a Connect scan (-sT)? (A Connect scan (-sT) completes the full TCP handshake, which is "noisy" and easily logged. A SYN scan (-sS) is stealthy and just sends the first SYN packet, resetting the connection before it completes).
What is a firewall? How can it stop nmap? (From syllabus. A firewall is a device that filters traffic. It can be configured to block nmap's probes, causing ports to show as "filtered").
What's the difference between an IDS and a Firewall? (A Firewall blocks based on rules (IP, port). An IDS detects based on patterns (e.g., it can be trained to see "this looks like an nmap scan" and send an alert)).
Why is the -A (aggressive) scan so useful to an attacker? (Because it combines OS detection and version detection. Exploits are specific to software versions, so finding "Apache 2.4.7" allows an attacker to search for a known vulnerability in that specific version).

Experiment 8: Cryptanalysis or Decoding of Vigenère Cipher
Aim:
To implement the Vigenère cipher in Java to encrypt and decrypt a given message ("Security") using your name as the key.
Algorithm/Theory:
The Vigenère cipher is a polyalphabetic substitution cipher. It uses a keyword to apply a series of different Caesar ciphers to the plaintext.
Our Java code implements this as follows:
Preparation (LowerToUpper): The code first converts both the plaintext and the keyword to uppercase.
Key Generation (generateKey): The code repeats the keyword until it is the same length as the plaintext. (e.g., Plaintext: "SECURITY", Key: "VAISHNAVI" -> Generated Key: "VAISHNAV").
Encryption (cipherText): The code iterates through the text. For each letter, it applies the formula:
x = (str.charAt(i) + key.charAt(j)) % 26
cipher_text += (char) (x + 'A')
This logic (using ASCII values) is equivalent to the standard formula C_i = (P_i + K_i)mod{26}, where A=0, B=1, etc.
Decryption (originalText): The code implements the inverse formula:
x = (cipher_text.charAt(i) - key.charAt(j) + 26) % 26
orig_text += (char) (x + 'A')
The + 26 is crucial to ensure the modulo operation works correctly for negative numbers.
Solving (Key = "VAISHNAVI", Message = "SECURITY"):
Input Plaintext: SECURITY
Input Key: VAISHNAVI
Generated Key (generateKey): VAISHNAV
Encrypt (cipherText): (Using A=0, B=1...)
S(18) + V(21) = 39 % 26 = 13 -> N
E(4) + A(0) = 4 % 26 = 4 -> E
C(2) + I(8) = 10 % 26 = 10 -> K
U(20) + S(18) = 38 % 26 = 12 -> M
R(17) + H(7) = 24 % 26 = 24 -> Y
I(8) + N(13) = 21 % 26 = 21 -> V
T(19) + A(0) = 19 % 26 = 19 -> T
Y(24) + V(21) = 45 % 26 = 19 -> T
Output Observed:
The program will ask for the text and keyword.
Ciphertext: NEKMYVTT
Original/Decrypted Text: SECURITY

Possible Viva Questions:
Why is Vigenère stronger than a mono-alphabetic cipher? (It uses multiple substitution alphabets (one for each letter in the key), which flattens the letter frequency distribution. 'E' gets encrypted to many different letters).
How is Vigenère broken? (By first finding the key length. You can use the Kasiski examination (finding repeated ciphertext blocks) or Index of Coincidence (a statistical method) to guess the key length. Once you have the length (e.g., 8), you can break the ciphertext into 8 separate groups, each of which is just a simple Caesar cipher that can be broken by frequency analysis).
What is a "one-time pad"? (A Vigenère cipher where the key is truly random and at least as long as the message. It is the only mathematically unbreakable cipher).
In your decryption code, why do you add + 26? (This is to handle negative numbers. If you have C='B' (1) and K='D' (3), the formula is (1 - 3) = -2. (-2) % 26 can be -2. Adding 26 gives (-2 + 26) % 26 = 24 % 26 = 24, which correctly decrypts to 'Y').
What is the "OSI Security Architecture"? (From syllabus. A model that defines security services (like confidentiality, authentication), mechanisms (like encryption, digital signatures), and attacks).